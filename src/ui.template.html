<!-- Consolidated Icon System -->
<!-- @include src/components/icons/_icon-system.html -->
<script src="../vendor/jszip.min.js"></script>
<body class="figma-plugin">
    
    <main>
        <!-- This is the main content wrapper -->
        <div class="content-wrapper" id="content-wrapper">
            
            <!-- This container will be populated by the script -->
            <div id="main-content-container">
                
                <!-- @include src/components/_skeleton-loader.html -->
                <!-- @include src/components/_empty-state.html -->

                <!-- Main UI (hidden by default) -->
                <div id="main-ui" style="display: none;">
                    <!-- Plugin Header with Theme Toggle -->
                    <div class="plugin-header">
                        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme" title="Switch between light and dark mode">
                            <span class="theme-toggle-track">
                                <span class="theme-toggle-thumb">
                                    <i data-icon="sun" class="theme-icon theme-icon-light"></i>
                                    <i data-icon="moon" class="theme-icon theme-icon-dark"></i>
                                </span>
                            </span>
                        </button>
                    </div>
                    
                    <!-- Token Summary Card -->
                    <div class="card token-summary" id="token-summary-card">
                        <!-- Token Summary will be injected here by the script -->
                    </div>
                    
                    <!-- Export Card Container -->
                    <div id="export-card-container" class="export-cards-section">
                        <!-- Quick Export View (Simple Mode) -->
                        <div id="quick-export-view">
                            <!-- @include src/components/_quick-export-card.html -->
                        </div>
                        
                        <!-- Advanced Filter View (Advanced Mode) -->
                        <div id="advanced-filter-view" class="state-hidden">
                            <div class="card filter-section is-compact">
                                <div class="card-content">
                                    <div style="display: flex; align-items: center; gap: var(--size-2); margin-bottom: var(--size-3);">
                                        <i data-icon="sliders-horizontal" style="width: 1em; height: 1em;"></i>
                                        <h4 class="text-label">Filters</h4>
                                    </div>
                                    <div class="collection-list" id="collection-list">
                                        <!-- Dynamic collection items will be injected here -->
                                    </div>
                                </div>
                                <div class="card-actions" style="margin-top: var(--size-3);">
                                    <button class="btn btn-secondary btn-sm" id="toggle-simple-mode" aria-label="Return to quick export mode">
                                        <i data-icon="arrow-left"></i>
                                        <span>Back to Quick Export</span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                </div>
            </div>

            <!-- @include src/components/_plugin-footer.html -->
        </div>
    </main>

    <!-- @include src/components/_about-modal.html -->
    
    <div class="progress-overlay" id="progress-overlay" style="display: none;"></div>

    <script>
        // --- STATE & CONFIG ---
        const appState = {
            mode: 'simple',
            collections: [],
            selectedCollections: new Set(),
            selectedFormats: new Set(['css', 'swift', 'android', 'flutter', 'w3c', 'tailwind']),
            selectedTokenTypes: new Set(['color', 'text', 'number', 'states']),
            globalTokenCounts: { color: 0, text: 0, states: 0, number: 0 },
        };

        const DOMElements = {
            skeletonLoader: document.getElementById('skeleton-loader'),
            emptyState: document.getElementById('empty-state'),
            mainUI: document.getElementById('main-ui'),
            tokenSummaryCard: document.getElementById('token-summary-card'),
            // New stateful elements
            exportCardContainer: document.getElementById('export-card-container'),
            quickExportView: document.getElementById('quick-export-view'),
            advancedFilterView: document.getElementById('advanced-filter-view'),
            // Theme toggle
            themeToggle: document.getElementById('theme-toggle'),
            // Modals and overlays
            aboutModal: document.getElementById('about-modal'),
            progressOverlay: document.getElementById('progress-overlay'),
            aboutLink: document.getElementById('about-link'),
        };

        // --- UTILITIES ---
        const openUrl = (url) => parent.postMessage({ pluginMessage: { type: 'open-url', url } }, '*');
        const debounce = (func, delay) => {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), delay);
            };
        };
        
        // --- THEME MANAGEMENT ---
        function initializeTheme() {
            // Get stored theme or default to light
            const storedTheme = localStorage.getItem('token-exporter-theme') || 'light';
            setTheme(storedTheme);
        }
        
        function setTheme(theme) {
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('token-exporter-theme', theme);
            
            if (DOMElements.themeToggle) {
                DOMElements.themeToggle.setAttribute('aria-pressed', theme === 'dark');
                DOMElements.themeToggle.classList.toggle('dark-mode', theme === 'dark');
            }
        }
        
        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        }
        
        // --- EASTER EGG: Logo Click Counter ---
        let logoClickCount = 0;
        const easterEggMessages = [
            "Keep clicking...",
            "Getting warmer...",
            "Almost there!",
            "ðŸŽ‰ You found the secret! You're clearly a design system enthusiast!",
            "âœ¨ Fun fact: This plugin was built with love and lots of coffee!",
            "ðŸš€ Thanks for being awesome!"
        ];
        
        function handleLogoClick() {
            logoClickCount++;
            if (logoClickCount >= 5 && logoClickCount < easterEggMessages.length + 5) {
                const messageIndex = logoClickCount - 5;
                const message = easterEggMessages[messageIndex];
                showTemporaryMessage(message);
            }
        }
        
        function showTemporaryMessage(message) {
            // Create a temporary toast-like message
            const toast = document.createElement('div');
            toast.className = 'easter-egg-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            // Remove after 3 seconds
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }
        const renderIcons = () => {
            try {
                console.log('[DEBUG] Rendering icons...');
                // Try both function names for compatibility
                if (window.renderIcons) {
                    window.renderIcons();
                    console.log('[DEBUG] Icons rendered using window.renderIcons');
                } else if (window.renderPluginIcons) {
                    window.renderPluginIcons();
                    console.log('[DEBUG] Icons rendered using window.renderPluginIcons');
                } else {
                    console.warn("Icon rendering function not found");
                }
            } catch (error) {
                console.error("Plugin icon rendering failed:", error);
            }
        };

        // --- UI UPDATE FUNCTIONS ---
        function updateUI() {
            DOMElements.mainUI.classList.toggle('advanced-mode', appState.mode === 'advanced');
            updateTokenSummary();
            updateExportAndCollections(); // Use the new unified function
            renderIcons();
            attachDynamicEventListeners();
        }


function updateTokenSummary() {
    console.log('[DEBUG] Updating token summary...');
    const totalTokens = Object.values(appState.globalTokenCounts).reduce((s, c) => s + c, 0);
    const selectedCount = appState.mode === 'simple' ? totalTokens : appState.collections.reduce((count, col) => {
        if (!appState.selectedCollections.has(col.id)) return count;
        return count + Object.entries(col.counts).reduce((subCount, [type, num]) => appState.selectedTokenTypes.has(type) ? subCount + num : subCount, 0);
    }, 0);

    const tokenLabelText = appState.mode === 'simple' ? 'Tokens Found' : 'Tokens Selected';

    const tokenTypesHTML = ['color', 'text', 'number', 'states'].map(type => {
        const iconMap = { color: 'palette', text: 'type', number: 'hash', states: 'toggle-right' };
        const count = appState.globalTokenCounts[type] || 0;
        const isActive = appState.selectedTokenTypes.has(type);
        return '<div class="token-type-stat ' + type + ' ' + (isActive ? 'active' : '') + ' ' + (count === 0 ? 'disabled' : '') + '" data-type="' + type + '">' +
                '<i class="icon" data-icon="' + iconMap[type] + '"></i>' +
                '<div class="count">' + count + '</div>' +
                '<div class="text-label label" style="color: var(--color-text-muted);">' + type + '</div>' +
            '</div>';
    }).join('');

    console.log('[DEBUG] Token types HTML includes icons:', tokenTypesHTML.includes('data-icon'));
    DOMElements.tokenSummaryCard.innerHTML = 
        '<div class="text-heading-xl token-count-total">' + selectedCount + '</div>' +
        '<div class="text-label token-label">' + tokenLabelText + '</div>' + 
        '<div class="token-breakdown">' + tokenTypesHTML + '</div>';
    console.log('[DEBUG] Token summary updated - icons need re-rendering');
}

                function updateExportAndCollections() {
            const isAdvanced = appState.mode === 'advanced';
            
            // Toggle visibility of the two views
            DOMElements.quickExportView.classList.toggle('state-hidden', isAdvanced);
            DOMElements.advancedFilterView.classList.toggle('state-hidden', !isAdvanced);

            if (isAdvanced) {
                // Build and inject the advanced view content
                const collectionItemsHTML = appState.collections.map(c => {
                    const isSelected = appState.selectedCollections.has(c.id);
                    const pillsHTML = Object.entries(c.counts).map(([type, count]) => {
                        if (count === 0) return '';
                        const iconMap = { color: 'palette', text: 'type', states: 'toggle-right', number: 'hash' };
                        const colorClassMap = { color: 'cyan', text: 'purple', number: 'orange', states: 'pink' };
                        return '<span class="badge small ' + colorClassMap[type] + ' ' + (!appState.selectedTokenTypes.has(type) ? 'disabled' : '') + '"><span class="icon" data-icon="' + iconMap[type] + '"></span> ' + count + '</span>';
                    }).join('');

                    return '<div class="collection-item ' + (isSelected ? 'selected' : '') + '" data-collection-id="' + c.id + '">' +
                        '<div class="collection-checkbox" role="checkbox" aria-checked="' + isSelected + '" tabindex="0" aria-label="Select ' + c.name + ' collection"></div>' +
                        '<div class="collection-info">' +
                            '<div class="text-body-lg collection-name">' + c.name + '</div>' +
                            '<div class="collection-pills">' + pillsHTML + '</div>' +
                        '</div>' +
                        '<div class="text-caption collection-count">' + c.totalVariables + ' tokens</div>' +
                    '</div>';
                }).join('');

                // Only update the collection list content, not the entire card
                const collectionListElement = document.getElementById('collection-list');
                if (collectionListElement) {
                    collectionListElement.innerHTML = collectionItemsHTML;
                }
            }
            
            // Always update the export button in the quick export view
            const selectedTokenCount = isAdvanced 
                ? appState.collections.reduce((count, col) => {
                    if (!appState.selectedCollections.has(col.id)) return count;
                    return count + Object.entries(col.counts).reduce((subCount, [type, num]) => appState.selectedTokenTypes.has(type) ? subCount + num : subCount, 0);
                }, 0)
                : Object.values(appState.globalTokenCounts).reduce((s, c) => s + c, 0);

            const exportBtn = document.getElementById('export-btn');
            if (exportBtn) {
                exportBtn.disabled = selectedTokenCount === 0;
                
                // Add satisfying click handler
                exportBtn.addEventListener('click', function() {
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = 'scale(1)';
                    }, 100);
                });
            }
        }

        // --- EVENT HANDLERS ---
        const debouncedUpdate = debounce(() => updateUI(), 250);

        function attachEventListeners() {
            // Theme toggle listener
            if (DOMElements.themeToggle) {
                DOMElements.themeToggle.addEventListener('click', () => {
                    toggleTheme();
                    // Add satisfying click animation
                    DOMElements.themeToggle.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        DOMElements.themeToggle.style.transform = 'scale(1)';
                    }, 100);
                });
            }
            
            // Static listeners
            DOMElements.aboutLink.onclick = (e) => {
                e.preventDefault();
                DOMElements.aboutModal.classList.add('show');
                renderIcons();
            };
            DOMElements.aboutModal.onclick = (e) => {
                if (e.target.closest('[data-close-modal]') || e.target.closest('.about-modal-backdrop') || e.target === DOMElements.aboutModal) {
                    DOMElements.aboutModal.classList.remove('show');
                }
            };
            DOMElements.aboutModal.querySelectorAll('.about-link').forEach(link => {
                link.onclick = (e) => {
                    e.preventDefault();
                    openUrl(link.dataset.url);
                };
            });
            // Note: emptyStateAction is now inside a partial, but this should still work
            // as long as the script runs after the DOM is populated.
            const emptyStateAction = document.querySelector('.empty-state-action');
            if (emptyStateAction) {
                emptyStateAction.addEventListener('click', () =>
                    openUrl('https://help.figma.com/hc/en-us/articles/360041085694-Create-and-use-variables')
                );
            }
            
            // Add easter egg to empty state logo
            const emptyStateLogo = document.querySelector('.empty-state .token-exporter-logo');
            if (emptyStateLogo) {
                emptyStateLogo.addEventListener('click', handleLogoClick);
                emptyStateLogo.style.cursor = 'pointer';
            }
        }

               function attachDynamicEventListeners() {
            const exportBtn = document.getElementById('export-btn');
            if (exportBtn) exportBtn.onclick = handleExport;

            const toggleAdvanced = document.getElementById('toggle-advanced-mode');
            if (toggleAdvanced) toggleAdvanced.onclick = () => {
                appState.mode = 'advanced';
                updateUI();
            };

            const toggleSimple = document.getElementById('toggle-simple-mode');
            if (toggleSimple) toggleSimple.onclick = () => {
                appState.mode = 'simple';
                updateUI();
            };

            document.querySelectorAll('.collection-item').forEach(item => {
                item.onclick = (e) => {
                    // Prevent clicks on badges from triggering selection
                    if (e.target.closest('.badge')) return;
                    
                    const id = item.dataset.collectionId;
                    if (appState.mode === 'advanced' && id) {
                        if (appState.selectedCollections.has(id)) {
                            appState.selectedCollections.delete(id);
                        } else {
                            appState.selectedCollections.add(id);
                        }
                        updateUI();
                    }
                };
                
                // Add keyboard support for accessibility
                item.onkeydown = (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        item.click();
                    }
                };
            });

            if (appState.mode === 'advanced') {
                document.querySelectorAll('.token-type-stat:not(.disabled)').forEach(stat => {
                    stat.onclick = () => {
                        const type = stat.dataset.type;
                        appState.selectedTokenTypes.has(type) ? appState.selectedTokenTypes.delete(type) : appState.selectedTokenTypes.add(type);
                        
                        // Add a delightful bounce animation on click
                        stat.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            stat.style.transform = 'scale(1.05)';
                            setTimeout(() => {
                                stat.style.transform = 'scale(1)';
                            }, 100);
                        }, 50);
                        
                        updateUI();
                    };
                });
            }

            // Multi-select format dropdown
            const formatTrigger = document.getElementById('format-select-trigger');
            const formatDropdown = document.getElementById('format-select-dropdown');
            const formatLabel = document.getElementById('format-select-label');
            const formatCheckboxes = document.querySelectorAll('.format-checkbox');
            
            if (formatTrigger && formatDropdown) {
                // Initialize all checkboxes as checked
                formatCheckboxes.forEach(cb => cb.checked = true);
                
                formatTrigger.onclick = (e) => {
                    e.stopPropagation();
                    const isExpanded = formatTrigger.getAttribute('aria-expanded') === 'true';
                    formatTrigger.setAttribute('aria-expanded', !isExpanded);
                    formatDropdown.hidden = isExpanded;
                    
                    // Add/remove dropdown-expanded class for CSS styling
                    const exportCard = document.querySelector('.export-section.has-inner-structure');
                    if (exportCard) {
                        if (!isExpanded) {
                            exportCard.classList.add('dropdown-expanded');
                        } else {
                            exportCard.classList.remove('dropdown-expanded');
                        }
                    }
                };
                
                // Handle checkbox changes
                formatCheckboxes.forEach(checkbox => {
                    checkbox.onchange = () => {
                        appState.selectedFormats.clear();
                        formatCheckboxes.forEach(cb => {
                            if (cb.checked) {
                                appState.selectedFormats.add(cb.value);
                            }
                        });
                        updateFormatLabel();
                    };
                });
                
                // Update label based on selection
                function updateFormatLabel() {
                    const count = appState.selectedFormats.size;
                    if (count === 0) {
                        formatLabel.textContent = 'No formats selected';
                    } else if (count === 6) {
                        formatLabel.textContent = 'All Formats';
                    } else if (count === 1) {
                        const format = Array.from(appState.selectedFormats)[0];
                        const labels = {
                            css: 'CSS Variables',
                            swift: 'Swift (iOS)',
                            android: 'Android XML',
                            flutter: 'Flutter',
                            w3c: 'JSON (W3C)',
                            tailwind: 'Tailwind Config'
                        };
                        formatLabel.textContent = labels[format] || format;
                    } else {
                        formatLabel.textContent = count + ' formats selected';
                    }
                }
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!formatTrigger.contains(e.target) && !formatDropdown.contains(e.target)) {
                        formatTrigger.setAttribute('aria-expanded', 'false');
                        formatDropdown.hidden = true;
                        
                        // Remove dropdown-expanded class
                        const exportCard = document.querySelector('.export-section.has-inner-structure');
                        if (exportCard) {
                            exportCard.classList.remove('dropdown-expanded');
                        }
                    }
                });
            }
        }
        
        // --- EXPORT & PROGRESS ---
        function handleExport() {
            const collectionIds = appState.mode === 'simple' ? appState.collections.map(c => c.id) : Array.from(appState.selectedCollections);
            const tokenTypes = Array.from(appState.selectedTokenTypes);
            if (collectionIds.length === 0 || tokenTypes.length === 0) return;
            const formats = Array.from(appState.selectedFormats);
            
            showProgress();
            
            parent.postMessage({ pluginMessage: { type: 'export-tokens', collectionIds, formats, activeTokenTypes: tokenTypes } }, '*');
        }

        function showProgress() {
            DOMElements.tokenSummaryCard.innerHTML = 
                '<div class="te-progress-loader" id="pluginProgressLoader" style="height: 194px;">' +
                    '<div class="te-icon-grid" id="pluginIconGrid"></div>' +
                    '<div class="te-celebration" id="pluginCelebration"></div>' +
                    '<div class="te-glass-status surface-glass" id="pluginGlassStatus">' +
                        '<p class="te-progress-percent te-progress-percent" id="pluginProgressPercent">0%</p>' +
                        '<div class="te-progress-track">' +
                            '<div class="te-progress-fill" id="pluginProgressFill"></div>' +
                        '</div>' +
                        '<p class="te-status-label te-status-label" id="pluginStatusLabel" aria-live="polite" aria-atomic="true">Ready to export</p>' +
                    '</div>' +
                '</div>';
            initializePluginLoader();
            
            // Start the beautiful animation sequence
            animateExportProgress();
        }
        
        // Match the design guide's beautiful timing
        function animateExportProgress() {
            // Track when we started for success timing
            animationStartTime = Date.now();
            
            // Reset progress
            currentProgress = 0;
            updateProgress(0);
            
            // Animate with the same timing as the guide
            setTimeout(() => updateProgress(25), 1500);   // 0 -> 25% at 1.5s
            setTimeout(() => updateProgress(50), 2700);   // 25 -> 50% at 2.7s
            setTimeout(() => updateProgress(75), 4000);   // 50 -> 75% at 4s
            setTimeout(() => updateProgress(100), 4500);  // 75 -> 100% at 4.5s
            // Success animation will trigger via message from Figma
        }
        
        // Store current progress for smooth animation
        let currentProgress = 0;
        let animationFrame = null;
        let animationStartTime = 0;
        
        function updateProgress(targetProgress) {
            const progressStages = [
                { percent: 25, label: "Analyzing" },
                { percent: 50, label: "Packaging" },
                { percent: 75, label: "Sanitizing" },
                { percent: 95, label: "Finalizing" }
            ];
            
            const percentEl = document.getElementById('pluginProgressPercent');
            const fillEl = document.getElementById('pluginProgressFill');
            const labelEl = document.getElementById('pluginStatusLabel');
            
            // Cancel any existing animation
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            // Smooth animation function
            function animateProgress() {
                const diff = targetProgress - currentProgress;
                const step = diff * 0.1; // Ease-out animation
                
                if (Math.abs(diff) > 0.5) {
                    currentProgress += step;
                    
                    if (percentEl) percentEl.textContent = Math.round(currentProgress) + '%';
                    if (fillEl) fillEl.style.width = currentProgress + '%';
                    
                    const currentStage = progressStages.find(s => currentProgress <= s.percent) || progressStages[progressStages.length - 1];
                    if (labelEl) labelEl.textContent = currentStage.label;
                    
                    animationFrame = requestAnimationFrame(animateProgress);
                } else {
                    // Final update
                    currentProgress = targetProgress;
                    if (percentEl) percentEl.textContent = targetProgress + '%';
                    if (fillEl) fillEl.style.width = targetProgress + '%';
                    
                    const currentStage = progressStages.find(s => targetProgress <= s.percent) || progressStages[progressStages.length - 1];
                    if (labelEl) labelEl.textContent = currentStage.label;
                }
            }
            
            animateProgress();
        }

        function showSuccessState(fileData) {
            const container = document.getElementById('pluginProgressLoader');
            if (!container) {
                updateTokenSummary();
                if (fileData && fileData.length > 0) triggerSave(fileData);
                return;
            }
            
            container.classList.add('te-celebrating');
            const grid = document.getElementById('pluginIconGrid');
            if(grid) grid.classList.add('fade-out');

            const celebrationContainer = document.getElementById('pluginCelebration');
            if(celebrationContainer) {
                const successIcon = document.createElement('div');
                successIcon.className = 'te-success-icon';
                successIcon.innerHTML = '<i data-icon="circle-check-big"></i>';
                celebrationContainer.appendChild(successIcon);
            }
            
            renderIcons();

            setTimeout(() => {
                updateTokenSummary();
                if (fileData && fileData.length > 0) {
                    triggerSave(fileData);
                }
            }, 5000);
        }
        
        function showErrorState(message) {
            // Make error messages more friendly and less scary
            const friendlyMessages = {
                'No tokens found': "Hmm, looks like we couldn't find any tokens to export. Maybe try creating some variables first?",
                'Export failed': "Oops! Something went sideways during export. Don't worry, it happens to the best of us!",
                'No collections selected': "Looks like no collections are selected. Pick some tokens to make the magic happen!"
            };
            
            const friendlyMessage = friendlyMessages[message] || "Something unexpected happened, but we're sure you'll figure it out!";
            
            DOMElements.tokenSummaryCard.innerHTML = 
                '<div class="progress-container error-state" style="animation: none; padding: var(--size-4); display:flex; flex-direction:column; align-items:center; justify-content:center; height: 194px; gap: var(--size-2);">' +
                    '<i data-icon="alert-triangle" class="icon icon--xl success-icon" style="color:var(--color-text-error); animation: gentle-wiggle 0.5s ease-in-out; margin-bottom: var(--size-2);"></i>' +
                    '<h2 class="text-heading-md success-title" style="margin-bottom: var(--size-1);">Oops!</h2>' +
                    '<p class="text-body-md success-subtitle" style="margin-bottom: var(--size-3); text-align: center;">' + friendlyMessage + '</p>' +
                    '<button class="btn btn-secondary btn-sm" id="close-error-btn" aria-label="Close error and try again">Let\'s Try Again âœ¨</button>' +
                '</div>';
            renderIcons();
            const closeBtn = document.getElementById('close-error-btn');
            if (closeBtn) closeBtn.onclick = updateTokenSummary;
        }

        async function triggerSave(data) {
            const link = document.createElement('a');
            
            if (data.length === 1) {
                const blob = new Blob([data[0].content], { type: 'text/plain;charset=utf-8' });
                link.href = URL.createObjectURL(blob);
                link.download = data[0].filename;
                link.click();
                URL.revokeObjectURL(link.href);
            } else if (data.length > 1) {
                // Create ZIP file for multiple formats
                try {
                    const zip = new JSZip();
                    
                    // Add each file to the ZIP
                    data.forEach(file => {
                        zip.file(file.filename, file.content);
                    });
                    
                    // Generate the ZIP file
                    const content = await zip.generateAsync({ type: 'blob' });
                    
                    // Create download link
                    link.href = URL.createObjectURL(content);
                    link.download = 'design-tokens.zip';
                    link.click();
                    URL.revokeObjectURL(link.href);
                } catch (error) {
                    console.error('Failed to create ZIP:', error);
                    // Fallback to individual downloads
                    data.forEach((file, index) => {
                        setTimeout(() => {
                            const fileLink = document.createElement('a');
                            const blob = new Blob([file.content], { type: 'text/plain;charset=utf-8' });
                            fileLink.href = URL.createObjectURL(blob);
                            fileLink.download = file.filename;
                            fileLink.click();
                            URL.revokeObjectURL(fileLink.href);
                        }, index * 300);
                    });
                }
            }
        }

        function initializePluginLoader() {
            const grid = document.getElementById('pluginIconGrid');
            if (!grid) return;
            
            const tokenTypes = [
                { icon: 'palette', color: '--value-color' }, { icon: 'type', color: '--value-text' },
                { icon: 'hash', color: '--value-number' }, { icon: 'toggle-right', color: '--value-state' }
            ];
            
            for (let i = 0; i < 80; i++) {
                const cell = document.createElement('div');
                cell.classList.add('te-icon-cell');
                
                const category = tokenTypes[i % tokenTypes.length];
                const icon = document.createElement('i');
                icon.setAttribute('data-icon', category.icon);
                cell.appendChild(icon);
                cell.style.setProperty('--color', 'var(' + category.color + ')');
                
                const angle = Math.random() * Math.PI * 2;
                const radius = 120 + Math.random() * 40;
                
                cell.style.setProperty('--x-start', Math.cos(angle) * radius + 'px');
                cell.style.setProperty('--y-start', Math.sin(angle) * radius + 'px');
                cell.style.setProperty('--x-end', Math.cos(angle + Math.PI) * radius + 'px');
                cell.style.setProperty('--y-end', Math.sin(angle + Math.PI) * radius + 'px');
                cell.style.setProperty('--delay', Math.random() * 1.5 + 's');
                cell.style.setProperty('--scale', 0.6 + Math.random() * 0.5);
                cell.style.setProperty('--blur', (Math.random() > 0.3) ? '0px' : Math.random() * 2 + 'px');
                
                grid.appendChild(cell);
            }
            renderIcons();
        }

        // --- WHIMSICAL LOADING MESSAGES ---
        let loadingMessageIndex = 0;
        let loadingMessageInterval = null;
        const loadingMessages = [
            "Discovering tokens...",
            "Exploring your design system...",
            "Counting beautiful variables...",
            "Organizing design magic...",
            "Finding color treasures...",
            "Collecting typography gems...",
            "Almost ready to export!"
        ];
        
        function startLoadingMessages() {
            const messageEl = document.getElementById('loading-message');
            if (!messageEl) return;
            
            loadingMessageInterval = setInterval(() => {
                loadingMessageIndex = (loadingMessageIndex + 1) % loadingMessages.length;
                messageEl.textContent = loadingMessages[loadingMessageIndex];
            }, 1200); // Change message every 1.2 seconds
        }
        
        function stopLoadingMessages() {
            if (loadingMessageInterval) {
                clearInterval(loadingMessageInterval);
                loadingMessageInterval = null;
            }
        }

        // --- INITIALIZATION ---
        function initialize() {
            console.log('[DEBUG] Initializing plugin...');
            
            // Initialize theme first
            initializeTheme();
            
            // Explicitly set the correct initial UI state.
            if (DOMElements.skeletonLoader) {
                DOMElements.skeletonLoader.style.display = 'block';
                console.log('[DEBUG] Skeleton loader visible');
                startLoadingMessages(); // Start the delightful messages
            }
            if (DOMElements.emptyState) DOMElements.emptyState.style.display = 'none';
            if (DOMElements.mainUI) DOMElements.mainUI.style.display = 'none';

            // Render icons for the skeleton loader.
            console.log('[DEBUG] Initial icon render for skeleton loader');
            renderIcons(); 

            // Immediately ask the main plugin for the variable collections.
            console.log('[DEBUG] Requesting collections from plugin...');
            parent.postMessage({ pluginMessage: { type: 'get-collections' } }, '*');

            // Attach all static event listeners.
            attachEventListeners();
        }

        window.onmessage = (event) => {
            const msg = event.data.pluginMessage;
            if (!msg) return;
            switch (msg.type) {
                case 'all-collections':
                    console.log('[DEBUG] Received collections:', msg.collections);
                    stopLoadingMessages(); // Stop the delightful messages
                    DOMElements.skeletonLoader.style.display = 'none';
                    appState.collections = msg.collections || [];
                    if (appState.collections.length === 0) {
                        // If no collections, show the empty state and hide the main UI
                        console.log('[DEBUG] No collections - showing empty state');
                        DOMElements.emptyState.style.display = 'flex';
                        DOMElements.mainUI.style.display = 'none';
                    } else {
                        // If collections exist, show the main UI and hide the empty state
                        console.log('[DEBUG] Collections found - showing main UI');
                        DOMElements.emptyState.style.display = 'none';
                        DOMElements.mainUI.style.display = 'block';
                        appState.globalTokenCounts = msg.globalCounts || { color: 0, text: 0, states: 0, number: 0 };
                        appState.selectedTokenTypes = new Set(Object.keys(appState.globalTokenCounts).filter(k => appState.globalTokenCounts[k] > 0));
                        appState.selectedCollections = new Set(appState.collections.map(c => c.id));
                        updateUI();
                    }
                    console.log('[DEBUG] About to render icons after collections loaded');
                    renderIcons();
                    break;
                case 'export-progress':
                    // Don't update if we're already animating smoothly
                    // This prevents jumpy behavior from Figma messages
                    break;
                case 'export-result':
                    // Wait for our animation to complete before showing success
                    const timeToWait = Math.max(0, 4800 - (Date.now() - animationStartTime));
                    setTimeout(() => showSuccessState(msg.data), timeToWait);
                    break;
                case 'notify':
                    if (msg.error) showErrorState(msg.message);
                    break;
            }
        };

        // --- Responsive Height Observer ---
        const resizeObserver = new ResizeObserver(entries => {
            const entry = entries[0];
            // Add a 16px buffer to the height to prevent scrollbars from flashing
            const height = entry.contentRect.height + 16; 
            parent.postMessage({ pluginMessage: { type: 'resize', width: 340, height: Math.round(height) } }, '*');
        });

        // Observe the main content wrapper for size changes
        const contentWrapper = document.getElementById('content-wrapper');
        if (contentWrapper) {
            resizeObserver.observe(contentWrapper);
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
